(de Litteral (content)
  (cond
    ((num? content) content)
    ((str? content) (pack "\"" content "\""))
    (T "Littéral de type inconnu.")
  ))
(de Variable inputs
  (let (nom_var (car inputs))
    (if nom_var nom_var "")
  )
)
(de + (A B) (pack "(" A "+" B ")"))
(de - (A B) (pack "(" A "-" B ")"))
(de * (A B) (pack "(" A "×" B ")"))
(de / (A B) (pack "(" A "/" B ")"))
(de % (A B) (pack "(" A "%" B ")"))
(de ^ (A B) (pack "pow(" A ", " B ")"))

(de !!! (comz) (pack "// " (cdr (reverse (cdr (reverse (chop comz))))) "^J"))
(de Afficher (obj) (pack "println(" obj ");^J"))
(de Declarer !arg_lst
  (let (!splitted (split !arg_lst 'De_type)
        !vars (mapcar 'cadr (car !splitted))  # var name is in (Variable ...)
        !type (caadr !splitted))
       (pack "float " (glue " " !vars) " de type " (cadr !type) ";^J")  # type is in (Litteral ...)
  )
)
(de Concatener @ (glue " + " (rest)))
(de Affecter_a !arg_lst
  (let (!var (cadr (car !arg_lst))  # var name is in (Variable ...)
        !val (eval (cadr !arg_lst)))
       (pack !var " = " !val ";")))
(de Entier@ (A B) (pack "int(" A " + random(" B "-" A "+1))"))
(setq Vrai "true")
(setq Faux "false")
(de Si arg_lst (let (condition (car arg_lst)
                     kw_alors  (cadr arg_lst)
                     splitted  (split (cddr arg_lst) 'Sinon)
                     bloc_vrai (car splitted)
                     bloc_faux (cadr splitted))
                    (pack
                      "if " (eval condition) "^J" "{^J"
                      (mapcar 'eval bloc_vrai)
                      (if bloc_faux (pack "} else {^J" (mapcar 'eval bloc_faux)))
                      "}^J"
                    )
                )
)
(de Non (bool) (pack "!(" bool ")"))
(de Et !arg_lst (pack "(" (glue " && " (mapcar 'eval !arg_lst)) ")"))
(de Ou !arg_lst (pack "(" (glue " || "  (mapcar 'eval !arg_lst)) ")"))
(de Tant_que arg_lst (let (!cond (car arg_lst)
                           !mot-clef (cadr arg_lst)
                           !corps (cddr arg_lst))
                          (pack
                            "while (" (eval !cond) ") {^J"
                            (mapcar 'eval !corps)
                            "}^J"
                          )
                     )
)
(de Faire arg_lst (let (!splitted (split arg_lst 'Tant_que)
                        !corps (car !splitted)
                        !cond (caadr !splitted))
                       (pack
                         "do{^J"
                         (mapcar 'eval !corps)
                         "} while (" (eval !cond) ")^J"
                       )
                  )
)

(de =  (A B) (pack "(" A " == " B ")"))
(de <  (A B) (pack "(" A " < "  B ")"))
(de <= (A B) (pack "(" A " <= " B ")"))
(de >  (A B) (pack "(" A " > "  B ")"))
(de >= (A B) (pack "(" A " >= " B ")"))
(de =/ (A B) (pack "(" A " != " B ")"))

(de Liste @ (pack "[" (glue ", " (rest)) "]"))

(de 1000Cosinus (angle) (pack "cos(radians(" angle "))"))
(de 1000Sinus   (angle) (pack "sin(radians(" angle "))"))

(de Longueur (A) (pack A ".length"))
(de Nieme (obj idx) (pack obj "[" idx "]"))
(de Millisecondes () "millis()")

(de RAZ () "background(255);^J")
(de Cercle inputs
  (let (origine (car inputs)
        orig_x  (eval (cadr origine))
        orig_y  (eval (caddr origine))
        r       (eval (cadr inputs)))
       (pack "ellipse(" orig_x ", " orig_y ", 2*" r ", 2*" r ");^J")
  )
)
(de Contour inputs
  (let (couleur (car inputs)
        R (eval (cadr couleur))
        V (eval (caddr couleur))
        B (eval (cadddr couleur)))
       (pack "stroke(" R ", " V ", " B ");^J")))
(de Remplissage inputs
  (let (couleur (car inputs)
        R (eval (cadr couleur))
        V (eval (caddr couleur))
        B (eval (cadddr couleur)))
       (pack "fill(" R ", " V ", " B ");^J")))
(de Ellipse inputs
  (let (origine (car inputs)
        orig_x  (eval (cadr origine))
        orig_y  (eval (caddr origine))
        r1      (eval (cadr inputs))
        r2      (eval (caddr inputs)))
       (pack "ellipse(" orig_x ", " orig_y ", 2*" r1 ", 2*" r2 ");^J")
  )
)
(de Epaisseur inputs
  (let (e (eval (cadr (car inputs))))
       (pack "strokeWeight(" e ");^J")
  )
)
(de Rectangle inputs
  (let (p1 (car inputs)
        p2 (cadr inputs)
        x1 (eval (cadr  p1))
        y1 (eval (caddr p1))
        x2 (eval (cadr  p2))
        y2 (eval (caddr p2)))
       (pack "rect(" x1 ", " y1 ", " x2 ", " y2 ");^J")
  )
)
(de Segment inputs
  (let (p1 (car inputs)
        p2 (cadr inputs)
        x1 (eval (cadr  p1))
        y1 (eval (caddr p1))
        x2 (eval (cadr  p2))
        y2 (eval (caddr p2)))
       (pack "line(" x1 ", " y1 ", " x2 ", " y2 ");^J")
  )
)
(de Triangle inputs
  (let (p1 (car inputs)
        p2 (cadr inputs)
        p3 (caddr inputs)
        x1 (eval (cadr  p1))
        y1 (eval (caddr p1))
        x2 (eval (cadr  p2))
        y2 (eval (caddr p2))
        x3 (eval (cadr  p3))
        y3 (eval (caddr p3)))
       (pack "triangle(" x1 ", " y1 ", " x2 ", " y2 ", " x3 ", " y3 ");^J")
  )
)
(de Repere () (!no_export "Repere"))

(de Tete () (!no_export "Tete"))
(de Queue () (!no_export "Queue"))
(de Ajouter_a () (!no_export "Ajouter_a"))
(de Retirer_de () (!no_export "Retirer_de"))
# En_position
(de Nieme@ () (!no_export "Nieme@"))
(de Texte () (!no_export "Texte"))
(de Nombre () (!no_export "Nombre"))
# Alors Sinon
(de Repeter () (!no_export "Repeter"))
(de ... () " (...) ")

(de !no_export (cmd)
  (pack "-- La commande " cmd " ne peut être exportée. --^J"))

(de Demander () (!no_export "Demander"))
(de Demander_un_nombre () (!no_export "Demander_un_nombre"))
(de Initialiser@() (!no_export "Initialiser@"))
(de Type () (!no_export "Type"))
(de Definir () (!no_export "Definir"))
(de Retourner () (!no_export "Retourner"))
(de Exemples_de () (!no_export "Exemples_de"))
(de Tester () (!no_export "Tester"))
(de ? () (!no_export "?"))
# Rien

(de AV () (!no_export "AV"))
(de BC () (!no_export "BC"))
(de LC () (!no_export "LC"))
(de TD () (!no_export "TD"))
(de TG () (!no_export "TG"))
